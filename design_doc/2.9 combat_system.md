# 2.9 战斗系统（Combat System）

## 2.9.1 概述
战斗系统负责管理游戏中的战斗逻辑，包括战斗触发、战斗过程、战斗结果处理等。战斗系统与场景系统解耦，场景系统只负责视觉呈现，战斗系统负责所有战斗相关的逻辑和状态管理。

## 2.9.2 核心要素

### 单场景战斗设计
- **保持单场景**：战斗在同一个场景中进行，不切换场景
- **视觉变化**：通过调整船只位置和显示敌方船只来表现战斗
- **状态驱动**：战斗状态通过`GameState`管理，场景系统响应状态变化

### 战斗触发机制
- **触发时机**：在航行过程中随机触发（航行进度10%-90%之间）
- **触发概率**：每跨越10%进度时，有10%概率触发战斗
- **触发条件**：
  - 必须在海上航行中（`isAtSea == true`）
  - 不在战斗中（`isInCombat == false`）
- **调试支持**：调试面板提供"立即触发战斗"按钮（详见 `2.7 debug_system.md`）

## 2.9.3 战斗流程

### 战斗开始
1. **保存状态**：保存当前港口（用于失败重生）
2. **创建敌方船只**：创建默认属性的敌方船只实例
3. **设置战斗状态**：
   - `isInCombat = true`
   - 初始化攻击进度累积器（重置所有计时器为0）
4. **触发视觉更新**：
   - 玩家船只向左移动150像素
   - 敌方船只从右侧滑入（场景系统处理）
5. **时间继续运行**：战斗时时间不暂停，继续按照统一的游戏时钟运行

### 战斗过程

#### 攻击机制
每个属性都有独立的计时器，按照真实频率触发：

- **玩家攻击**：
  - 使用`fireRatePerSecond`（来自船员系统的炮手技能）
  - 计算触发间隔：`attackInterval = 1.0 / fireRatePerSecond`
  - 例如：5炮/秒 = 0.2秒/炮
  - 累积时间：`playerAttackTimer += dt`
  - 当`playerAttackTimer >= attackInterval`时，造成伤害并重置计时器
  - 每次攻击造成固定伤害（默认10点）
  - 使用`while`循环处理可能的多重触发（如果dt很大）
  
- **敌方攻击**：
  - 使用敌方船只的`fireRatePerSecond`（默认1炮/秒）
  - 计算触发间隔：`attackInterval = 1.0 / enemyFireRate`
  - 例如：1炮/秒 = 1.0秒/炮
  - 累积时间：`enemyAttackTimer += dt`
  - 当`enemyAttackTimer >= attackInterval`时，造成伤害并重置计时器
  - 每次攻击造成固定伤害（默认10点）

#### 修复机制
每个属性都有独立的计时器，按照真实频率触发：

- **玩家修复**：
  - 使用`autoRepairPerSecond`（来自船员系统的船工技能）
  - 计算触发间隔：`repairInterval = 1.0 / repairRatePerSecond`
  - 例如：2点/秒 = 0.5秒/点
  - 累积时间：`playerRepairTimer += dt`
  - 当`playerRepairTimer >= repairInterval`且耐久未满时，恢复1点耐久并重置计时器
  - 战斗中继续生效
  
- **敌方修复**：
  - 使用敌方船只的`repairRatePerSecond`（默认2点/秒）
  - 计算触发间隔：`repairInterval = 1.0 / enemyRepairRate`
  - 例如：2点/秒 = 0.5秒/点
  - 累积时间：`enemyRepairTimer += dt`
  - 当`enemyRepairTimer >= repairInterval`且耐久未满时，恢复1点耐久并重置计时器

#### 触发时机说明
- **独立计时**：每个属性（玩家攻击、敌方攻击、玩家修复、敌方修复）都有独立的累积时间
- **真实频率**：按照频率的倒数计算触发间隔，确保触发时机准确
- **不同时机**：由于每个属性的频率不同，它们的触发时机也不同
  - 例如：玩家攻击5炮/秒（0.2秒触发），敌方攻击1炮/秒（1.0秒触发），玩家修复2点/秒（0.5秒触发）
  - 它们会在不同的时间点触发，不会同步

#### 战斗更新循环
- 由主游戏循环调用`updateCombatWithDeltaTime(dtGameSeconds)`
- 使用游戏时间增量（dtGameSeconds），而不是现实时间增量
- 游戏时间增量 = `dtRealSeconds * timeScale * timeMultiplier / 60.0`
- 分别更新每个属性的累积时间（基于游戏时间）
- 检查每个属性是否达到触发间隔
- 如果达到，执行相应操作并重置计时器
- 检查战斗结果（任一船只耐久<=0）
- **统一时钟**：所有战斗参数（攻击、修复）使用统一的游戏时钟作为唯一衡量标准

### 战斗结果

#### 玩家获胜
1. **设置沉船状态**：`isSinking = true`, `isPlayerSinking = false`
2. **触发沉船动画**：敌方船只向下移动（场景系统处理，2秒）
3. **清理战斗状态**：
   - `isInCombat = false`
   - 清理敌方船只
   - 停止战斗更新循环
4. **恢复场景**：
   - 玩家船只回到中央位置（`playerShipXOffset = 0.0`）
   - 敌方船只移出屏幕（`enemyShipXOffset = 1.0`）
5. **继续航行**：战斗结束后继续航行到目标港口（时间一直在运行，无需恢复）

#### 玩家失败
1. **设置沉船状态**：`isSinking = true`, `isPlayerSinking = true`
2. **触发沉船动画**：玩家船只向下移动（场景系统处理，2秒）
3. **等待3秒**：给玩家时间看到沉船效果
4. **重生处理**：
   - 恢复船只耐久度到最大值
   - 清理战斗状态
   - 停止航行
   - 重置到出发前的港口（不是目标港口）
   - 恢复船只位置
   - 暂停时间流逝（在港口）

## 2.9.4 数据模型

### 敌方船只（EnemyShip）
```dart
class EnemyShip {
  final String id;
  final String name;
  int durability;
  final int maxDurability;        // 默认200
  final double fireRatePerSecond; // 默认1.0炮/秒
  final double repairRatePerSecond; // 默认2.0点/秒
  final int damagePerShot;        // 默认10点
}
```

### 战斗状态（GameState）
```dart
// 战斗状态
bool isInCombat;
EnemyShip? enemyShip;
DateTime? lastCombatUpdateTime;

// 每个属性独立的累积时间（秒）
double playerAttackTimer;  // 玩家攻击累积时间
double enemyAttackTimer;   // 敌方攻击累积时间
double playerRepairTimer;  // 玩家修复累积时间
double enemyRepairTimer;   // 敌方修复累积时间

// 船只位置（用于场景系统）
double playerShipXOffset;  // 玩家船只X偏移
double enemyShipXOffset;   // 敌方船只X偏移

// 沉船状态
bool isSinking;
bool isPlayerSinking;

// 重生相关
Port? previousPortBeforeCombat;
```

## 2.9.5 敌方船只属性

### 默认属性
- **耐久度**：200
- **攻击频率**：1炮/秒
- **修复频率**：2点/秒
- **每次伤害**：10点

### 属性说明
- 所有敌方船只使用相同的默认属性（固定值）
- 未来可以扩展为根据玩家等级或船只等级动态调整
- 属性值可以在`EnemyShip.createDefault()`中配置

## 2.9.6 战斗动画

### 玩家船只左移
- **实现方式**：直接设置`playerShipXOffset = -150.0`
- **动画时长**：立即（无动画）
- **位置**：向左移动150像素

### 敌方船只滑入
- **实现方式**：场景系统使用`SlideTransition`
- **动画时长**：1500ms
- **起始位置**：`Offset(1.0, 0.0)`（屏幕外右侧）
- **结束位置**：`Offset.zero`（正常位置）
- **缓动曲线**：`Curves.easeInOut`

### 沉船动画
- **实现方式**：场景系统使用`AnimationController`
- **动画时长**：2秒
- **动画效果**：y坐标增加800像素（向下移动）
- **缓动曲线**：`Curves.easeIn`
- **触发时机**：战斗结果确定后

## 2.9.7 技术实现

### 战斗系统位置
- **状态管理**：`lib/game/game_state.dart`
- **敌方船只模型**：`lib/models/enemy_ship.dart`
- **视觉呈现**：`lib/game/layers/ship_layer.dart`（场景系统）
- **主循环调用**：`lib/main.dart`（游戏循环中调用战斗更新）

### 统一游戏时钟
- **时间基准**：战斗系统使用统一的游戏时钟（`DayNightSystem`）
- **时间不暂停**：战斗时时间继续运行，不调用`pause()`
- **游戏时间增量**：战斗更新使用游戏时间增量（秒），而不是现实时间增量
- **时间倍数影响**：当debug panel调整时间倍数时，战斗速度也会相应变化
- **计算公式**：`dtGameSeconds = dtRealSeconds * timeScale * timeMultiplier / 60.0`

### 核心方法

#### 开始战斗
```dart
void startCombat() {
  // 保存当前港口（用于失败重生）
  _previousPortBeforeCombat = _currentPort;
  
  // 创建敌方船只
  _enemyShip = EnemyShip.createDefault();
  
  // 设置战斗状态
  _isInCombat = true;
  _isSinking = false;
  _isPlayerSinking = false;
  // 重置所有计时器
  _playerAttackTimer = 0.0;
  _enemyAttackTimer = 0.0;
  _playerRepairTimer = 0.0;
  _enemyRepairTimer = 0.0;
  
  // 注意：战斗时时间不暂停，继续按照统一的游戏时钟运行
  
  // 暂停航行进度更新（不更新时间，但战斗期间不累积航行距离）
  _progressTicker?.stop();
  
  // 调整船只位置
  _playerShipXOffset = -150.0;
  _enemyShipXOffset = 1.0;
  
  notifyListeners();
}
```

#### 更新战斗（主循环调用）
```dart
// 在主游戏循环中
if (_gameState.isInCombat) {
  // 计算游戏时间增量（秒）
  final dtGameSeconds = dtRealSeconds * timeScale * timeMultiplier / 60.0;
  _gameState.updateCombatWithDeltaTime(dtGameSeconds);
}

// 在 GameState 中
void updateCombatWithDeltaTime(double dtGameSeconds) {
  // dtGameSeconds 是游戏时间增量（秒），不是现实时间
  // 所有战斗参数基于统一的游戏时钟
  
  // 玩家攻击：按照真实频率触发
  final playerFireRate = fireRatePerSecond;
  if (playerFireRate > 0) {
    _playerAttackTimer += dtGameSeconds;
    final attackInterval = 1.0 / playerFireRate; // 例如：5炮/秒 = 0.2秒/炮
    
    while (_playerAttackTimer >= attackInterval) {
      _enemyShip!.takeDamage(_enemyShip!.damagePerShot);
      _playerAttackTimer -= attackInterval;
    }
  }
  
  // 敌方攻击：按照真实频率触发
  final enemyFireRate = _enemyShip!.fireRatePerSecond;
  if (enemyFireRate > 0) {
    _enemyAttackTimer += dtGameSeconds;
    final attackInterval = 1.0 / enemyFireRate;
    
    while (_enemyAttackTimer >= attackInterval) {
      _ship.durability = (_ship.durability - _enemyShip!.damagePerShot).clamp(0, _ship.maxDurability);
      _enemyAttackTimer -= attackInterval;
    }
  }
  
  // 玩家修复：按照真实频率触发
  final playerRepairRate = autoRepairPerSecond;
  if (playerRepairRate > 0 && _ship.durability < _ship.maxDurability) {
    _playerRepairTimer += dtGameSeconds;
    final repairInterval = 1.0 / playerRepairRate; // 例如：2点/秒 = 0.5秒/点
    
    while (_playerRepairTimer >= repairInterval && _ship.durability < _ship.maxDurability) {
      _ship.durability = (_ship.durability + 1).clamp(0, _ship.maxDurability);
      _playerRepairTimer -= repairInterval;
    }
  }
  
  // 敌方修复：按照真实频率触发
  final enemyRepairRate = _enemyShip!.repairRatePerSecond;
  if (enemyRepairRate > 0 && _enemyShip!.durability < _enemyShip!.maxDurability) {
    _enemyRepairTimer += dtGameSeconds;
    final repairInterval = 1.0 / enemyRepairRate;
    
    while (_enemyRepairTimer >= repairInterval && _enemyShip!.durability < _enemyShip!.maxDurability) {
      _enemyShip!.repair(1.0);
      _enemyRepairTimer -= repairInterval;
    }
  }
  
  // 检查战斗结果
  if (_enemyShip!.isSunk) {
    _handleCombatVictory();
  } else if (_ship.durability <= 0) {
    _handleCombatDefeat();
  }
}
```

## 2.9.8 与场景系统的关系

### 职责分离
- **战斗系统**：负责战斗逻辑、状态管理、胜负判断
- **场景系统**：负责视觉呈现、动画效果、船只渲染

### 状态同步
- 战斗系统通过`GameState`管理战斗状态
- 场景系统通过监听`GameState`的状态变化来更新视觉
- 两个系统通过`GameState`进行解耦

### 视觉更新流程
1. 战斗系统修改`GameState`中的战斗状态
2. `GameState`调用`notifyListeners()`
3. 场景系统的`ShipLayer`响应状态变化
4. 更新船只位置和显示敌方船只

## 2.9.9 与船员系统的关系

### 攻击频率
- 使用`GameState.fireRatePerSecond`（来自船员系统的炮手技能）
- 计算公式：`fireRatePerSecond = 所有炮手的gunnerSkill总和`
- **参考**：详见 `2.4 crew_system.md`（开炮速度）

### 修复频率
- 使用`GameState.autoRepairPerSecond`（来自船员系统的船工技能）
- 战斗中继续生效：船工的自动修理在战斗中仍然有效
- 计算公式：`autoRepairPerSecond = 所有船工的shipwrightSkill总和`
- **参考**：详见 `2.4 crew_system.md`（自动修理）

## 2.9.10 与导航系统的关系

### 战斗触发
- 战斗在航行过程中随机触发
- 触发检查在导航系统的进度更新中进行
- 战斗期间暂停航行进度更新

### 战斗结果影响
- **玩家获胜**：继续航行到目标港口
- **玩家失败**：取消航行，重生在出发前的港口

## 2.9.11 与昼夜系统的关系

### 统一游戏时钟
- **时间不暂停**：战斗时时间继续运行，不调用`DayNightSystem.pause()`
- **统一时间基准**：战斗系统使用统一的游戏时钟，与其他系统（如船员工资、价格更新）保持一致
- **时间倍数影响**：当debug panel调整时间倍数时，战斗速度也会相应变化
- **游戏时间增量**：战斗更新使用游戏时间增量（秒），计算公式：`dtGameSeconds = dtRealSeconds * timeScale * timeMultiplier / 60.0`

### 时间计算
- 战斗更新由主游戏循环调用，确保使用统一的游戏时钟
- 所有战斗参数（攻击、修复）基于游戏时间进行触发
- 战斗期间时间继续流逝，影响所有基于时间的系统（如船员工资结算）

## 2.9.12 调试支持

### 立即触发战斗
- 调试面板提供"立即触发战斗"按钮
- 在航行中点击按钮可立即触发战斗
- 用于快速测试战斗系统
- **参考**：详见 `2.7 debug_system.md`（立即触发战斗按钮）

## 2.9.13 扩展性

### 可扩展的功能
- **敌方船只类型**：不同类型的敌方船只有不同属性
- **难度调整**：根据玩家等级或船只等级动态调整敌方属性
- **战斗奖励**：战斗胜利后获得金币或物品
- **战斗技能**：玩家可以使用特殊技能
- **多敌战斗**：同时与多个敌方船只战斗
- **战斗动画**：添加炮火、爆炸等视觉效果

---

**最后更新**：2024年（战斗系统实现）

